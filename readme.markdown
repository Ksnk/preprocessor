﻿
# Где взять. как скачать?

<http://ksnk.github.com/preprocessor/preprocessor.tar.gz> - здесь можно скачать последнюю актуальную версию.

Сам проект находится здесь - <https://github.com/Ksnk/preprocessor>

## Оглавление

* [Условная компиляция в PHP. Фантастику в жизнь](#toc1)
* [Введение или зачем оно нужно](#toc2)
* [Как оно работает?](#toc3)
* [Описание файла конфигурации](#toc4)
* [Макро ООП.](#toc5)
* [Как его запускать, как его ипользовать.](#toc6)
* [Исходные файлы препроцессора.](#toc7)
* [Рецепты](#toc8)
    * [Как вставить "шапку" в каждый файл проекта](#toc9)
    * [У меня проект на github.](#toc10)
    * [Вставить кусок файла в файл проекта](#toc11)
    * [Мой редактор не любит ASP-like теги и говорит, что это ошибки](#toc12)
    * [Мне нужно вставить кусок текста в комментарий](#toc13)
    * [В конце файла хочется поместить текст лицензионного соглашения](#toc14)

# <a name="toc1"/>Условная компиляция в PHP. Фантастику в жизнь


## <a name="toc2"/>Введение или зачем оно нужно

Казалось бы, зачем благородному дону условная компиляция в php?

Однако, при создании web-проектов зачастую не хватает этапа "компиляции" скриптов проекта. К примеру, в шапки всех текстов, выкладываемых на целевой сервер неплохо бы вставить информацию о проекте, ревизии SVN и какую-нибудь сопроводительную муть. При создании ajax приложения возникает настойчивое желание спрятать в javascript-строку формочки и стили, созданные в обычном html редакторе.

При рисовании какой-нибудь заковыристой формочки, основанной на картинке, размеры этой картинки "гармонично" вливаются в javascript, css и разметку. Отсутствие констант в CSS служит источником вдохновения для создателей SASS...

Для демонстрации работы заказчику, часто требуется размещать проект на разных серверах с разным окружением. В итоге код проекта приходится слегка модифицировать для того или иного сервера, той или иной среды.

Изредка посещают крамольные мысли – сделать код одновременно для php4 и для php5.

Как правило, для таких целей используются файлы конфигурации, в которые, с соблюдением определенной ловкости рук, упакованы все кардинальные отличия проекта, в зависимости от погодных условий.

Однако решение некоторых этих проблем уже есть. Нужно ввести дополнительный язык препроцессора и его выполнить...

## <a name="toc3"/>Как оно работает?

Web-программист - специалист по PHP и достаточно логично, что язык препроцессора будет тем же PHP. Тем более, что PHP и есть, с какой-то точки зрения, достаточно универсальный язык препроцесоора. При этом совершенно бесплатно препроцессор приобретает всю могутность PHP, которой так не хватает другим языкам препроцессинга. Вот только теги препроцессора должны отличатся от тегов PHP, чтобы не возникало недоразумений. Пусть они будут asp-like `<% %>`. Чтобы "выполнить" такой текст - достаточно заменить все PHP теги на что-то другое, поменять asp-like на php теги и исполнить их обычным eval'ом. После этого - вернуть php теги взад. It's easy... Хотя, чтобы сделать эту простую идею еще и полезной - нужно ее усложнить и понять, что же обычно требуется для сборки проекта.

Чтобы не путать с функциями обычного PHP, будем называть функции и константы, описанные в тегах препроцессора макрами или макрокомандами. В принципе, они именно этим и являются...

Часто приходится собирать несколько "целей" - комплектов файлов для разных условий содержания. Для отладки на локальном сервере, для отладки на целевом сервере, для выкладывания конечному клиенту. Так что наш проект - это комплект файлов, которые берутся из разных мест с девелоперской машины и помещаются в определенные каталоги "билда". Pазличать варианты сборок будем по имени "цели", которую будем хранить в макре $target.

Чтобы можно было спокойно пользоваться макрами определенными в других файлах проекта, нужно исполнять их все в одном цикле. Тогда не нужно будет особенно заботится о видимости макрокоманд. Зато сам этап исполнения разбивается на 3 этапа - подготовка текста файла проекта к исполнению, путем замены тегов, собственно исполнение и возврат тегов обратно. Так что сначала нам придется каким-то образом описать весь комплект файлов проекта, а потом уже пробежаться по этому списку.

Сам препроцессор будет набором скриптов на php и будет запускаться в CLI режиме. Достаточно несложно включить такой вариант использования в ant/phing-сборщик или просто в батник, для хардкорщиков. При запуске скрипта мы передадим ему параметры

  `/usr/local/php5/php.exe -f /preprocessor/preprocessor.php /Dtarget=release /Ddst=build/$target config.xml`

параметр /D - описание переменных c именами target и dst соответственно. Потом эти переменные можно будет использовать.

Все переменные окружения доступны в скрипте с префиксом env_.

  `set common=/project`

переменная будет доступна с именем $env_common

В результате выполнения, появится комплект файлов, модифицированный для того или иного варианта сборки. Время модификации файлов будет скопировано (touch) из времени модификации исходных файлов. Для файлов, описанных в секции copy или file, которые не содержат тегов препроцессора, время будет браться из исходного файла. Для файлов, собранных препроцессором - время будет максимальным из времен всех "исходных" файлов, включая config.xml.

если "время" исходных файлов осталось не больше, чем время готового файла - собственно копирования и обработки файла не производится, что существенно ускоряет работу с большими объемами файлов проекта.

диагностика ошибок выполнения eval'уируемого кода проверена на php 5.2.8.8 Мне она представляется странной, однако, вроде работает ;)

## <a name="toc4"/>Описание файла конфигурации

Для того, чтобы сообщить препроцессору какие файлы входят в проект - создадим xml файл (config.xml). Вот такого, примерно, вида

    <?xml version="1.0" encoding="UTF-8"?>
    <config>
        <var name="license"><![CDATA[
    ----------------------------------------------------------------------------
    License GNU/LGPL - Serge Koriakin - June 2010
    http://forum.vingrad.ru/users/ksnk
    ----------------------------------------------------------------------------
    ]]></var>
        <files>
            <file>rev.tmp</file>
        </files>
        <files dir="../cms/plugins">
            <file>altname.php</file>
        </files>
        <files dstdir="$dst">
            <file>index.php</file>
            <file name=".htaccess">htaccess.txt</file>
            <file>project.php</file>
            <file>*.css</file>
            <file>.htaccess</file>
            <copy>style/*.*</copy>
            <file>engine/hosts.*</file>
            <file>engine/main.*</file>
            <file>engine/project_core.*</file>
            <copy>img/*.*</copy>
            <file>js/*.*</file>
            <file>templates/*.*</file>
        </files>
        <files dstdir="$dst" dir="../debug/debug">
            <copy>Debug/HackerConsole/*.*</copy>
        </files>
        <files  dstdir="$dst">
            <copy>uploaded/*.*</copy>
        </files>
    </config>

Все используемые здесь пути вычисляются относительно расположения самого config.xml

`config` - объемлющие скобки этого xml

`var` - завести строковую переменную с именем name. В текстах проекта этой переменной можно пользоваться внутри тегов препроцессора. Можно пользоваться параметром default, чтобы определить переменную, которой не было присвоено значение ранее. Областью видимости переменной будет тот блок групповых тегов, в котором она описана

`import` - параметр NAME тега указывает на xml файл, файлы из которого будут вставлены в этот список. При этом имя XLM файла задается относительно текущего XML, а имена файлов в новом XML - относительно его самого Таким образом можно импортировать файлы из других проектов.

`files` - объединяет группу файлов с одинаковыми параметрами dir и dstdir, а также служит ограничителем области видимости тегов var и remove.
  dir - каталог, откуда будут браться файлы, dstdir - куда они будут помещаться.
  name - имя группы файлов. Эту группу можно исключить по имени тегом remove.
  depend  - маски файлов через ";", по которым определяется максимальное время модификации, или
  depend='{время}' - явно указанное время. Все фалы билда, время модификации которых менее заданного, будут пересобраны

`file` - маска файлов, с которыми будет проводится "выполнение" препроцессором. Каталог перед именем файла означает, что в каталоги билда будет создана такая же структура. Кстати, здесь могут быть заданы свои параметры dir и dstdir, которые перекрывают параметры "верхнего" уровня. В дополнение может быть задан параметр name - имя файла, в который будет копироваться исходный

	<files dstdir="$dst" dir="../debug/debug">
	    <copy>Debug/HackerConsole/*.*</copy>
	</files>

этот кусок, к примеру, означает, что все файлы `../debug/debug/Debug/HackerConsole/*.*` будут размещены в каталоге
$dst/Debug/HackerConsole

	<file name=".htaccess">htaccess.txt</file>

означает, что файл htaccess.txt будет помещен в нужный каталог под именем ___.htaccess___.
(одна из причин такого переименования та, что Eclipse не любит показывать файлы с точкой вначале имени в списке файлов проекта).

`$dst` - переменная, которая задается в командной строке.

`copy` - все файлы, подходящие под маску будут просто скопированы в каталог назначения без eval'а с теми же правилами по поводу каталогов.

`echo` - весь текст внутри тега воспринимается как содержимое файла. Если необходимо записать содержимое в файл, нужно ставить параметр ___NAME___.

	<files dstdir="$dst">
	    <echo name="readme.txt"><![CDATA[<%=point('readme','wiki_txt');%>]]></echo>
	</files>

`remove` - выкидывает из сформированного списка файлы по маске. при этом выкидываются файлы по "исходному" имени. Следует понимать, что "сокращенное" имя при формировании пары "файл - место назначения", заменяется на полное имя до исходного файла. Файл, который попадает под маску "выкидывания" не выполняется. В качестве символов для маски используются

* \* - аналог [^:/\\]* - все символы, кроме / :
* ** - .* - вообще все символы
* ? - [^:/\\.] - один символ внутри имени файла.

`<remove>**/chat/*</remove>` - будут выкинуты все имена, находящиеся в каталоге chat. Например ___/project/version/chat/chat.php.___ но не _/project/version/chat.php_

    <files name="tdd.debug.email_test">... </files>
    <files name="debug.chat_debug">... </files>
    ...
    <remove name="tdd.*"/>

выкинуть из списка файлы, описанные в группе. вместо имени может использоваться маска, которая будет применяться к именам групп файлов.

Если конструкция внутри тега remove начинается и заканчивается символом тильда ~, то оно считается регулярным выражением и непосредственно применяется ко всем именам в парах.

область действия remove ограничена тегом files, в котором он описан. Если тег встречается вне тега files, функция применяется ко всему уже сформированному списку файлов. Список файлов заполняется последовательно, по мере чтения файла конфигурации, так что после remove можно опять вставлять файлы

## <a name="toc5"/>Макро ООП.

Отвлечемся теперь от всей этой мути и представим себе работающий web-проект. Вообразим себе, что начальнику проекта приспичило вставить в проект фенечку, использующую диалоговое окошко, описанное в некоем плагине. Этот плагин предполагает, что будут добавлены некие стили в файл стилей, добавлена некая разметка в html файл, добавлены некие файлы в каталог проекта и изменен один или несколько javaScript файлов проекта. Если наша фенечка использует ajax, при этом возникнет желание поменять и php-файлы. Изменения каждый раз невелики, однако они размазаны по большому количеству файлов, уследить за ними даже с использованием системы контроля версий может быть непросто. Особенно страшно становится, когда начальник в творческих муках перебирает многие варианты таких фенечек от разных производителей.

Как наш новоявленный компилятор может облегчить нашу судьбу в этом случае? Легко!

Мысленно представим себе куда и как мы будем вставлять компоненты фенечки. В функцию, вызывающуюся в методе onload документа будет вставлен код инициализации фенечки. Вставим туда код

    <% point ('js_onload'); %>

В том-же файле нам нужно описать поведение фенечки. Все это мы запихаем в область файла, в которой описываются все такие функции общего назначения

    //<% point ('js_body'); %>

В css файл мы будем добавлять некие стили. Туда запихаем:

    <% point ('css_styles'); %>

В html шаблон окна приложения нужно вставить заготовку диалогового окна. Туда поместим

    <% point ('html_body'); %>

Вот, вроде и все, если про ajax пока забыть…

А теперь, со всем этим хозяйством начнем взлетать. Соединим все конструктивные части фенечки в одном файле, однако разделим эти конструктивные части конструкциями POINT::start и POINT::finish.

      <html>
      <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>fenechka module</title>
      <script type=”text/javascript”>
          <% POINT::start('js_body'); %>
          function Fenechka(){

          }
          <% POINT::start('js_onload'); %>
          Fenechka();
          <% POINT::finish(); %>
      </script>

      <style type=”text/css”>
          <% POINT::start('css_style'); %>
          #fenechka { visible:none;}
          <% POINT::finish(); %>
      </style>
      </head>

      <body>
      <% POINT::start('html_body'); %>

      <div id="fenechka">Hello world!</div>
          <% POINT::finish(); %>
      </div>

      </body>
      </html>

При некоторой ловкости рук, файл с модулем может одновременно оказаться простой тестовой площадкой для проверки фенечки в отдельном окне. Впрочем, не в этом счастье.

Добавим строчку `<file>fenechka.html</file>` в первый блок (без указания параметра _dir_, чтобы не произошло копирование самого файла) нашего файла конфигурации, откомпилируем проект и незамедлительно, после исправления совсем уж явных опечаток, случится чудо! Все необходимые части нашего нового функционала вставятся в правильные места нашего проекта. Если по какой-то причине использование фенечки не понравится заказчикам, чтобы убрать ее из проекта, достаточно выкинуть одну строку конфигурации.

Реализация механизма находится в файле point.ext.php исходника.

## <a name="toc6"/>Как его запускать, как его ипользовать.

Запуск и использование препроцессора можно посмотреть в исходниках самого препроцессора.

config.xml представляет собой пример файла конфигурации с достаточно навороченной структурой, который омжет служить отправной точкой для вашео собственного конфигурационного файла.

Запуск препроцессора может быть выполнен с помошью phing. Для этого в нужное место в каталоге дополнений phing нужно разместить содержмое каталога build/phing.

Можно пользоваться build.bat, который включен в проект. Нужно убедиться, что в нем корректно указан путь до php-интерпретатора.

## <a name="toc7"/>Исходные файлы препроцессора.

Исходные тексты препроцессора находятся в каталоге src. Каталог build является результатом "препроцессинга" исходных файлов. В файлах выполняется внедрение версии в help - функцию, дополнение шапок в файлах и кое-что еще... Файл readme.txt и readme.html изготовлен из этого файла с использованием markdown-html и markdown-txt фильтров.

Для создания препроцессора использовался PHP storm с Phing’ом и система с установленным TortuiseGIT что накладывает отпечаток на используемые инструменты.

`Build.xlm` – make-файл для Phing’а. Он описывает пару макрокоманд – init – собственно вызов препроцессора и property – определение параметров +  вызов утилиты SubWCRev для внедрения номера ревизии SVN в текст.

`Config.xml` – файл конфигурации препроцессора, список файлов проекта

`preprocessor.php` - главный файл, анализ командной строки и вызов препроцессора

`preprocessor.class.php` - класс с методами препроцессора - сборка и хранение пар Source-Destination, исполнение файла препроцессором, собственно чтение и анализ файла конфигурации.

`point.ext.php` - набор функций, для реализации MACRO-OOP.

`wiki.ext.php` - класс для работы с wiki-разметкой. разметка пока сильно упрощенная.

`markdown.filter\*.*` - набор фильтров для обслуживания markdwn разметки. Сейчас используется оригинальный markdown от John Gruber <http://daringfireball.net/projects/markdown/> , но в планах заменить его на свой.


## <a name="toc8"/>Рецепты


### <a name="toc9"/>Как вставить "шапку" в каждый файл проекта

Вот рецепт, которым я сам пользовался для SVN.

* для начала необходимо вставить в каждый файл "заготовку" шапки

        /**
         * Some words about file in project
         *
         * <%=point('hat','comment');


         %>
         */

Обратите внимание, что после point(...); пропущены строки! Дело в том, что шапка занимает в получившемся файле несколько строк, так что сообщения об ошибках и варнингах окажутся смещенными на эти несколько строк в бOльшую сторону. Чтобы это не раздражало - не помешает добавить несколько пустых строк.

* затем в файл сборки проекта вставить таргет

        <target name="property">
                <echo file="svn.prop" append="false"><![CDATA[
            version=PHP Preprocessor, written by Ksnk (sergekoriakin@gmail.com). Ver : 1.1
            license=License GNU/LGPL - Serge Koriakin - Jule 2010-2012
            svn_revision=$WCREV$
            svn_modified=$WCDATE$
            svn_url=$WCURL$
            ]]>        </echo>
                <exec executable="SubWCRev" dir=".">
                    <arg file="." />
                    <arg file="svn.prop" />
                    <arg file="svn.prop" />
                    <arg value="-f" />
                </exec>
        </target>

после этого в файле svn.prop будет обработанная с помощью SVN шапка проекта.

* добавить загрузку параметров из svn.prop при сборке проекта. Для этого нужно
  добавить /Psvn.prop /force='${svn_modified}' в строку запуска препроцессора. Второй параметр - для
  пересборки, в случае изменения номера ревизии.
  весь таргет сборки выглядит, к примеру, так

        <target name="build" depends="property">
            <property file="../env.prop"/> <!-- определяем php_exe -->
            <property file="svn.prop"/>    <!-- определяем ревизию SVN -->
            <property name="target" value="release"/>
            <property name="dst" value="build"/>
            <property name="config" value="config.xml"/>
            <exec
               command="${php_exe} -q ../preprocessor/preprocessor.php /Psvn.prop /force='${svn_modified}' /Dtarget=${target} /Ddst=${dst} ${config}"
               checkreturn="true"
               logoutput="true"/>

            <delete file="svn.prop"/>
        </target>

* добавить вот такое в config.xml проекта

        <files>
                <echo>
                    <![CDATA[<% POINT::inline('hat',
        '----------------------------------------------------------------------------
        $Id: '.$version.'
         Rev: '.$svn_revision.', Modified: '.$svn_modified.'
         SVN: '.$svn_url.'$
        ----------------------------------------------------------------------------
        '.$license.'
        ----------------------------------------------------------------------------') ;%>]]>
                </echo>

            </files>

### <a name="toc10"/>У меня проект на github.

Одна из проблем git - нет очевидного понятия "номер ревизии", которое присутствует в SVN. В SVN оно настолько удобно, что многие пользуются им вместо младшего номера версии. Оказывается, не все так сложно с git. Номер ревизии там тоже есть. Его можно полцучить командой `git describe --tags`. Ну и еще немного магии...

Создайте в config.xml секцию:

        <var name="git" default="git"/>
        <files>
            <echo>
                <![CDATA[<%
                //
                // информация, которая будет появляться в шапке файлов
                //
                $version="PHP Preprocessor, written by Ksnk (sergekoriakin@gmail.com)";
                $license="License MIT - Serge Koriakin - Jule 2010-2012";

                //
                // получаем тег и ревизию
                //
                $output=array();
                $tag = exec($git." describe --tags", $output);

                //
                // получаем строку с адресом GIT репозитория.
                // Если он не один - исправляnm здесь
                //
                $output=array();
                $git_url = exec($git." remote -v", $output);

                //
                // список измененных файлов для вывода в трассу
                //
                $output=array();    exec($git." status -uno -s", $output);
                $output =implode("\n",$output);
                $status='';
                if(""!=(trim($modified=preg_replace("#\n+#","\n"
                    ,preg_replace('#^.*?build/.*?$#m','',$output)
                )))){
                // выводим список модифицированных файлов для ощущения
                // контроля над ситуацией
                    preprocessor::log(2,'"'.$modified."\"\n");
                    if(preg_match('#src/\w#',$output))
                        $status="status : draft build.\n";
                };
                $buildtime=date('ymdHi'); POINT::inline('hat',
    '----------------------------------------------------------------------------
    $Id: '.$version.',
    ver: '.$tag.', Last build: '.$buildtime.'
    '.$status.'GIT: '.$git_url.'$
    ----------------------------------------------------------------------------
    '.$license.'
    ----------------------------------------------------------------------------') ;
    %>]]>
            </echo>
        </files>

В результате, в точке с именем 'hat' будет лежать что-то, примерно такого вида

      ----------------------------------------------------------------------------
      $Id: PHP Preprocessor, written by Ksnk (sergekoriakin@gmail.com),
      ver: v1.2-1-g37eb78d, Last build: 1202221224
      status : draft build.
      GIT: origin	https://github.com/Ksnk/preprocessor (push)$
      ----------------------------------------------------------------------------
      License MIT - Serge Koriakin - Jule 2010-2012
      ----------------------------------------------------------------------------

Эту шапку можно вставлять в файлы так, как описано в предыдущем рецепте.

### <a name="toc11"/>Вставить кусок файла в файл проекта

Если некоторый файл не пришло еще время оформлять как плагин, а пользоваться им уже хочется, можно сделать так:

* файл site.css

        /*
        <% POINT::file('css_site','../common/regedit.css');
        %>
        */
        ...
        /* <% POINT::get("css_site"); %> */
        ...

* в файле config.xml нужно в секции, которая отвечает за генерацию нужного файла поставить параметр `depend`. Тогда при изменении зависимого файла будет автоматически перегенерироваться основной.

        ...
        <file depend="common/*.css">css/*.*</file>
        ...

### <a name="toc12"/>Мой редактор не любит ASP-like теги и говорит, что это ошибки

При генерации текстов препроцессором автоматически удаляются пустые теги-комментарии `/* */`? если внутри только пробельные символы. Так что теги препроцессора можно вставлять прямо в `/* ... */` комментариях. В некоторых случаях нужно, чтобы тег выводил значение в текст

     /* <%=POINT::get('mypoint'); */

При этом будет обнаружено, что точка вставки располагается в комментариях и к этому комментарию будет автоматически сгенерирован закрывающий тег. После окончания вывода будет сгенерирован открывающий тег.

Можно использовать вставки кода препроцессора в комментариях другого вида

    // <%=POINT::get('mypoint');%>
    ## <%=POINT::get('mypoint');%>

Во всех этих случаях препроцессор обнаружит строковые комментарии и выведет  текст на следующей строке/ Правда такие комментарии не удаляются автоматически.


### <a name="toc13"/>Мне нужно вставить кусок текста в комментарий

пользуйтесь фильтром 'comment' при вставке. Предположим, что в текст нужно вставить двустрочный текст.

    Часть проекта ABCDEFG,
    Copyright (c) XXXX

Фильтр позволяет распознать место, в которое делается попытка свтавить текст и определить как его нужно оформлять.

* комментарии // - большинство языков

        // <%=POINT::get('mypoint','comment');%>

    получится

        // Часть проекта ABCDEFG,
        // Copyright (c) XXXX


* комментарии ## - язык шаблонов, основаный на Django-шаблонах

        ## <%=POINT::get('mypoint','comment');%>


        ## Часть проекта ABCDEFG,
        ## Copyright (c) XXXX

* многострочный комментарий  /* ... */
    каждая новая строчка вставляемого текста будет снабжена соответствующим комментарием

        /**
         * <%=POINT::get('mypoint','comment');%>
         */

    каждая новая строчка текста будет снабжена * в нужной позиции.

        /**
         * Часть проекта ABCDEFG,
         * Copyright (c) XXXX
         */

### <a name="toc14"/>В конце файла хочется поместить текст лицензионного соглашения

В конец файла вставляем что-то вроде вот такого

        /************************************************************************************
         *
         * <% if($target!='allinone')
            POINT::file('license','mit.licence.ru.txt');
         else
           POINT::inline('license','# License agreement

        follow <http://www.gnu.org/copyleft/lesser.html> to see a complete text of license');

             echo POINT::get('license','markdown-txt|comment') ;
        %> ***********************************************************************************
         */

Как можно заметить, заполнение точки хранения лицензии можно произвести из файла или непосредственно в тексте. Вывод точки проходит через  фильтры `markdown-txt` - преобразует markdown - разметку в текстовый формат с выравниванием по 70 литер в строке. Затем - фильтр `comment` добавляет комментарии перед каждой новой строкой. Выглядит достаточно стильно.

        /************************************************************************************
         *
         * Лицензионное соглашение.
         * ========================
         *
         *     Copyright (c) 2012 Serge Koriakin <sergekoriakin@gmail.com>
         *
         * Данная  лицензия  разрешает  лицам,  получившим   копию   данного   программного
         * обеспечения и сопутствующей документации (в дальнейшем  именуемыми  «Программное
            ...
         * ТPЕБОВАНИЙ ПО ДЕЙСТВУЮЩИМ КОНТPАКТАМ, ДЕЛИКТАМ ИЛИ ИНОМУ, ВОЗНИКШИМ ИЗ,  ИМЕЮЩИМ
         * ПPИЧИНОЙ  ИЛИ  СВЯЗАННЫМ   С   ПPОГPАММНЫМ   ОБЕСПЕЧЕНИЕМ   ИЛИ   ИСПОЛЬЗОВАНИЕМ
         * ПPОГPАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫМИ ДЕЙСТВИЯМИ С ПPОГPАММНЫМ ОБЕСПЕЧЕНИЕМ.
         *
         *
         ***********************************************************************************
         */